---
title: "BsAbunance"
author: "zagor"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: true
      smooth_scroll: true
    fig_caption: yes
    self_contained: yes
    fig_width: 9
    fig_height: 6
    number_sections: yes
    theme: flatly
    highlight: tango
editor_options: 
  chunk_output_type: console
---
```{r setup, include=FALSE}

knitr::opts_chunk$set(#dev = c('pdf', 'png'),
                      dev = c('png', 'svg', 'pdf'), 
                      fig.align = 'center', 
                      fig.height = 6, 
                      fig.width = 9,
                      warning = FALSE, message = FALSE, echo = TRUE
                      )


```


```{r}

rm(list = ls(all = TRUE))
gc()


```


# Notes

- Multiple genotypes and unequal group sizes
- Each plant contributes multiple observations -> complex tissue structure


- Binary outcome
- Fixed effects: Genotype, Tissue (Genotype * tissue part (interaction))
- Random effects: Plant nested within Genotype (1 | Genotype/plant)
- Binomial outcome


# Bayesian generalized linear model1s with group-specific terms via Stan
- [rstanarm GitHub](https://github.com/stan-dev/rstanarm)
- [vignette](https://mc-stan.org/rstanarm/articles/rstanarm.html)

## MCMC diagnostics
- random effect-level variation : Sigma
- large and positive effect -> strongly increases the probability of output = 1 (mean, sd, ... cols)
- Rhat ≈ 1.0 : Chains converged perfectly, Rhat ≈ 1.0; Rhat > 1.1: problematic
- n_eff - higher is better (ideally > 1000); >1500 : Effective sample size is strong
- mcse ~ 0.0	: Monte Carlo error is negligible

##  indices relevant to describe and characterize the posterior distribution
- pd: Probability of Direction — the probability the effect is strictly positive or negative
- ROPE	Region of Practical Equivalence — a range around zero considered 'negligible'
- % in ROPE	- Percentage of the posterior within the ROPE — higher means the effect is likely trivial




# packages

```{r}

library(magrittr)
library(data.table)
library(ggplot2)

```


# Bs Abundance L6

```{r, input_L6}

fp = file.path('..', 'input')

fn = 'Table_combinedInputs.xlsx'
wb = openxlsx::loadWorkbook(file.path(fp, fn))
sheet_names = names(wb)
sheet_name = grep("BsAbundance_L6", sheet_names, value = TRUE)

dt = openxlsx::read.xlsx(file.path(fp, fn), sheet = sheet_name, startRow = 10)
empty_col_index = which(names(dt) == "")[1]
# subset to columns before the first empty one
if (!is.na(empty_col_index)) {
  dt = dt[, 1:(empty_col_index - 1)]
} 

setDT(dt)
dt[, Sample.ID := NULL]
table(dt$Strain)
table(dt$Treatment)


```

## inoculated

```{r, inoculated_L6}

inn = dt[dt$Treatment == 'inoculated', ]

inn$output = NA
inn$`Positive/Negative.sample` = trimws(inn$`Positive/Negative.sample`)
inn$output[inn$`Positive/Negative.sample` == '+'] = 1
inn$output[inn$`Positive/Negative.sample` == '-'] = 0


table(inn$Tissue, inn$output)
inn$part = gsub(' .*', '', inn$Tissue)
table(inn$part, inn$output, inn$Genotype)
inn$plant = sub('P', '', inn$Plant.No)

table(inn$Genotype, inn$part)
table(inn$Genotype, inn$plant)


inn = inn[, .SD, .SDcols = grep("Genotype|output|part|plant$", names(inn), ignore.case = TRUE)]

inn$Genotype = as.factor(inn$Genotype)
inn$part = as.factor(inn$part)
inn$plant = as.factor(inn$plant)

inn = inn[!is.na(inn$output), ]


```


## plot counts

```{r, counts_L6}

plot_data = inn %>%
  dplyr::filter(!is.na(output)) %>%
  dplyr::group_by(Genotype, part, output) %>%
  dplyr::summarise(count = dplyr::n(), .groups = "drop")

plot_data$output = factor(plot_data$output, levels = c(0, 1), labels = c("-", "+"))

ggplot(plot_data, aes(x = part, y = count, fill = output)) +
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ Genotype, ncol = 1) +
  labs(title = "",
       x = "part position",
       y = "+/- counts",
       fill = "Abundance") +
  theme_minimal() +
  scale_fill_manual(values = c('grey', 'darkgreen'))



```


## Bayesian generalized linear model1s with group-specific terms via Stan


```{r, bayes_L6}


set.seed(123456)

inn$part = relevel(inn$part, ref = "1st")  # changes reference level


model1 = rstanarm::stan_glmer(
  output ~ 0 + Genotype * part + (1 | Genotype/plant),
  data = inn,
  family = binomial(),
  chains = 10,  # default is 4
  iter = 1000,
  seed = 123456,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
)

model2 = rstanarm::stan_glmer(
  output ~ 0 + Genotype * part + (1 | Genotype/plant) + (1 | Genotype:plant:part),
  data = inn,
  family = binomial(),
  chains = 10,  # default is 4
  iter = 1000,
  seed = 123456,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
)

model3 = rstanarm::stan_glmer(
  output ~ 0 + Genotype + (1 | Genotype:plant:part),
  data = inn,
  family = binomial(),
  chains = 10,  # default is 4
  iter = 1000,
  seed = 123456,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
)

rstanarm::pp_check(model1) 
mean(rstanarm::bayes_R2(model1))
rstanarm::pp_check(model2)   
mean(rstanarm::bayes_R2(model2))
rstanarm::pp_check(model3)   
mean(rstanarm::bayes_R2(model3))

# Compares the distribution of observed outcomes (y) to the distribution of simulated outcomes (yrep)
yrep = rstanarm::posterior_predict(model1)

# Uses bar plots to show how often each outcome (0 or 1) occurs
bayesplot::ppc_bars(y = inn$output, yrep = yrep) # Bar plot of observed vs predicted
# bayesplot::ppc_dens_overlay(y = inn$output, yrep = yrep)  # Density overlay
bayesplot::ppc_bars_grouped(y = inn$output, yrep = yrep, group = inn$part)
bayesplot::ppc_bars_grouped(y = inn$output, yrep = yrep, group = inn$Genotype)




# Compute a Bayesian version of R-squared for regression model1s
r2_samples = rstanarm::bayes_R2(model2)
# On average,  model1 explains about XY% of the variance in the binary outcome
mean(r2_samples)  # Average R² across posterior
# 95% Credible Interval
quantile(r2_samples, probs = c(0.025, 0.975))  # 95% credible interval



# Cross-Validation
# Pareto k diagnostics measure how well the importance sampling works for each observation
# Values: 
#   k < 0.5 : good
#   0.5 < k < 0.7 : okay 
#   k > 0.7 : problematic 
#   k > 1 : very problematic
# observations with Pareto k>0.7 are influential and may distort the reliability of your Leave-One-Out (LOO) cross-validation estimates
loo_result = loo::loo(model2, k_threshold = 0.7)
# print(loo_result)
plot(loo_result)
# pk = loo::pareto_k_values(loo_result)
# inn[which(pk > 0.7), ]

# extracting the combined posterior samples across all chains
posterior = as.matrix(model2)
# all
posterior_array = as.array(model2)

# colnames(posterior)
bayesplot::mcmc_pairs(
  posterior_array,
  pars = c(
    "GenotypeRywal",
    "part4th",
    "GenotypeshPTI5-Rywal L6",
    "GenotypeshPTI5-Rywal L6:part4th"
  )
)


bayesplot::mcmc_trace(posterior, pars = c("GenotypeRywal","part4th",
                                          "GenotypeshPTI5-Rywal L6", "GenotypeshPTI5-Rywal L6:part4th"))



# Each line represents one MCMC chain sampling a parameter
# The x-axis is the iteration number; the y-axis is the sampled value
plot(model2, plotfun = "trace")
summary(model2)  # Should be close to 1



# Marginal means 
# higher prob -> higher chance of output = 1
emm_genotype = emmeans::emmeans(model2, ~ Genotype | part, type = "response")
# Pairwise comparisons
summary(pairs(emm_genotype, adjust = "BH"))
emmeans::emmip(model2, Genotype ~ part, CIs = TRUE, type = "response")
# nicer plot than above
df_emm = as.data.frame(emm_genotype) %>%
  dplyr::rename(prob = prob, lower = lower.HPD, upper = upper.HPD) %>%
  dplyr::mutate(
    part = factor(part, levels = unique(part)),    # keep existing order
    Genotype = factor(Genotype)
  )
plt = ggplot(df_emm, aes(x = part, y = prob, color = Genotype, group = Genotype)) +
  geom_line(position = position_dodge(width = 0.6), size = 0.8, alpha = 0.9) +
  geom_point(position = position_dodge(width = 0.6), size = 3, stroke = 0.9) +
  geom_errorbar(aes(ymin = lower, ymax = upper),
                position = position_dodge(width = 0.6),
                width = 0.18, size = 0.8, alpha = 0.9) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, 1)) +
  scale_color_viridis_d(option = "D", begin = 0.2, end = 0.8) +
  labs(
    x = "Leaf part",
    y = "Predicted probability of outcome = 1",
    color = "Genotype",
    title = "Estimated marginal probabilities by Genotype and tissue part",
    subtitle = "Posterior means with 95% credible intervals"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "right",
    axis.text.x = element_text(angle = 30, hjust = 1),
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank()
  )
print(plt)


emm_tissue = emmeans::emmeans(model2, ~ part | Genotype, type = "response")
# Pairwise comparisons
summary(pairs(emm_tissue, adjust = "BH"))


bayestestR::describe_posterior(model2)
# e.g. Very strong evidence that apex leaves strongly reduce the probability of output




```


## simplistic approach

```{r, simple_L6}

# Express Table Entries as Fraction of Marginal Table
prop.table(table(inn$Genotype, inn$output), 1)

# Fisher's Exact Test for Count Data
fisher.test(table(inn$Genotype, inn$output))

for (i in levels(inn$part)) {
  cat("Tissue: ", i, '\n')
  tmp = table(inn[part == i, .(Genotype, output)])
  for (lvl in c("0","1")) if (!(lvl %in% colnames(tmp))) {
    tmp = cbind(tmp, setNames(rep(0, nrow(tmp)), lvl))
    colnames(tmp)[2] = lvl}
  tmp = tmp[, c("0","1")] 
  # print("Proportions")
  # print(prop.table(tmp, 1))
  cat("Fisher's Exact Test for Count Data p-value: ", fisher.test(tmp)$p.value, '\n')
}



```



# Bs Abundance L2

- Genotype — highest level
- plant IDs are reused within genotypes (plant is nested within Genotype)
- parts (apex, 1st, 2nd, …) are repeated within plants (part is nested within plant)
- output: 0/1 - perfect separation


```{r, input_L2}

fp = file.path('..', 'input')

fn = 'Table_combinedInputs.xlsx'
wb = openxlsx::loadWorkbook(file.path(fp, fn))
sheet_names = names(wb)
sheet_name = grep("BsAbundance_L2", sheet_names, value = TRUE)

dt = openxlsx::read.xlsx(file.path(fp, fn), sheet = sheet_name, startRow = 10)
empty_col_index = which(names(dt) == "")[1]
# subset to columns before the first empty one
if (!is.na(empty_col_index)) {
  dt = dt[, 1:(empty_col_index - 1)]
} 

setDT(dt)
dt[, Sample.ID := NULL]
table(dt$Strain)
table(dt$Treatment)


```

## inoculated

```{r, inoculated_L2}

inn = dt[dt$Treatment == 'inoculated', ]

inn$output = NA
inn$`Positive/Negative.sample` = trimws(inn$`Positive/Negative.sample`)
inn$output[inn$`Positive/Negative.sample` == '+'] = 1
inn$output[inn$`Positive/Negative.sample` == '-'] = 0


table(inn$Tissue, inn$output)
inn$part = gsub(' .*', '', inn$Tissue)
table(inn$part, inn$output, inn$Genotype)
inn$plant = sub('P', '', inn$Plant.No)

table(inn$Genotype, inn$part)
table(inn$Genotype, inn$plant)


inn = inn[, .SD, .SDcols = grep("Genotype|output|part|plant$", names(inn), ignore.case = TRUE)]

inn$Genotype = as.factor(inn$Genotype)
inn$part = as.factor(inn$part)
inn$plant = as.factor(inn$plant)

inn = inn[!is.na(inn$output), ]

```


## plot counts

```{r, counts_L2}

plot_data = inn %>%
  dplyr::filter(!is.na(output)) %>%
  dplyr::group_by(Genotype, part, output) %>%
  dplyr::summarise(count = dplyr::n(), .groups = "drop")

plot_data$output = factor(plot_data$output, levels = c(0, 1), labels = c("-", "+"))

ggplot(plot_data, aes(x = part, y = count, fill = output)) +
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ Genotype, ncol = 1) +
  labs(title = "",
       x = "Tissue",
       y = "Ccounts",
       fill = "Abundance") +
  theme_minimal() +
  scale_fill_manual(values = c('grey', 'darkgreen'))



```




## Bayesian generalized linear model1s with group-specific terms via Stan


```{r, bayes_L2}


set.seed(123456)

inn$part = relevel(inn$part, ref = "1st")  # changes reference level



model1 = rstanarm::stan_glmer(
  output ~ 0 + Genotype * part + (1 | Genotype/plant),
  data = inn,
  family = binomial(),
  chains = 10,  # default is 4
  iter = 1000,
  seed = 123456,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
)

rstanarm::pp_check(model1)   

# Compares the distribution of observed outcomes (y) to the distribution of simulated outcomes (yrep)
yrep = rstanarm::posterior_predict(model1)

# Uses bar plots to show how often each outcome (0 or 1) occurs
bayesplot::ppc_bars(y = inn$output, yrep = yrep) # Bar plot of observed vs predicted
# bayesplot::ppc_dens_overlay(y = inn$output, yrep = yrep)  # Density overlay
bayesplot::ppc_bars_grouped(y = inn$output, yrep = yrep, group = inn$part)
bayesplot::ppc_bars_grouped(y = inn$output, yrep = yrep, group = inn$Genotype)




# Compute a Bayesian version of R-squared for regression model1s
r2_samples = rstanarm::bayes_R2(model1)
# On average,  model1 explains about XY% of the variance in the binary outcome
mean(r2_samples)  # Average R² across posterior
# 95% Credible Interval
quantile(r2_samples, probs = c(0.025, 0.975))  # 95% credible interval



# Cross-Validation
# Pareto k diagnostics measure how well the importance sampling works for each observation
# Values: 
#   k < 0.5 : good
#   0.5 < k < 0.7 : okay 
#   k > 0.7 : problematic 
#   k > 1 : very problematic
# observations with Pareto k>0.7 are influential and may distort the reliability of your Leave-One-Out (LOO) cross-validation estimates
loo_result = loo::loo(model1, k_threshold = 0.7)
# print(loo_result)
plot(loo_result)
# pk = loo::pareto_k_values(loo_result)
# inn[which(pk > 0.7), ]

# extracting the combined posterior samples across all chains
posterior = as.matrix(model1)
# all
posterior_array = as.array(model1)

# colnames(posterior)
bayesplot::mcmc_pairs(
  posterior_array,
  pars = c(
    "GenotypeRywal",
    "partapex",
    "GenotypeshPTI5-Rywal L2",
    "GenotypeshPTI5-Rywal L2:partapex"
  )
)


bayesplot::mcmc_trace(posterior, pars = c("GenotypeRywal","partapex",
                                          "GenotypeshPTI5-Rywal L2", "GenotypeshPTI5-Rywal L2:partapex"))



# Each line represents one MCMC chain sampling a parameter
# The x-axis is the iteration number; the y-axis is the sampled value
plot(model1, plotfun = "trace")
summary(model1)  # Should be close to 1



# Marginal means 
# higher prob -> higher chance of output = 1
emm_genotype = emmeans::emmeans(model1, ~ Genotype | part, type = "response")
# Pairwise comparisons
summary(pairs(emm_genotype, adjust = "BH"))
emmeans::emmip(model1, Genotype ~ part, CIs = TRUE, type = "response")
# nicer plot than above
df_emm = as.data.frame(emm_genotype) %>%
  dplyr::rename(prob = prob, lower = lower.HPD, upper = upper.HPD) %>%
  dplyr::mutate(
    part = factor(part, levels = unique(part)),    # keep existing order
    Genotype = factor(Genotype)
  )
plt = ggplot(df_emm, aes(x = part, y = prob, color = Genotype, group = Genotype)) +
  geom_line(position = position_dodge(width = 0.6), size = 0.8, alpha = 0.9) +
  geom_point(position = position_dodge(width = 0.6), size = 3, stroke = 0.9) +
  geom_errorbar(aes(ymin = lower, ymax = upper),
                position = position_dodge(width = 0.6),
                width = 0.18, size = 0.8, alpha = 0.9) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, 1)) +
  scale_color_viridis_d(option = "D", begin = 0.2, end = 0.8) +
  labs(
    x = "Leaf part",
    y = "Predicted probability of outcome = 1",
    color = "Genotype",
    title = "Estimated marginal probabilities by Genotype and tissue part",
    subtitle = "Posterior means with 95% credible intervals"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "right",
    axis.text.x = element_text(angle = 30, hjust = 1),
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank()
  )
print(plt)


emm_tissue = emmeans::emmeans(model1, ~ part | Genotype, type = "response")
# Pairwise comparisons
summary(pairs(emm_tissue, adjust = "BH"))


bayestestR::describe_posterior(model1)
# e.g. Very strong evidence that apex leaves strongly reduce the probability of output




```


## simplistic approach

```{r simple_L2}

# Express Table Entries as Fraction of Marginal Table
prop.table(table(inn$Genotype, inn$output), 1)

# Fisher's Exact Test for Count Data
fisher.test(table(inn$Genotype, inn$output))

for (i in levels(inn$part)) {
  cat("Tissue: ", i, '\n')
  tmp = table(inn[part == i, .(Genotype, output)])
  for (lvl in c("0","1")) if (!(lvl %in% colnames(tmp))) {
    tmp = cbind(tmp, setNames(rep(0, nrow(tmp)), lvl))
    colnames(tmp)[2] = lvl}
  tmp = tmp[, c("0","1")] 
  # print("Proportions")
  # print(prop.table(tmp, 1))
  cat("Fisher's Exact Test for Count Data p-value: ", fisher.test(tmp)$p.value, '\n')
}



```



# session info

```{r, sessionInfo}

sessionInfo()

```




